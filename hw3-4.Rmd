---
title: "Homework 3--4"
author: "Vladimir Yashin"
output: 
  html_notebook: 
    toc: yes
---
### Gibbs sampler (Ross, Exercise 10b)

The following returns a DF that contains points (with two coords) on a circle with radius 
`r` that no two points is closer to each other than `d`
```{r}
unif_circle <- function(threshold = 10000, r = 1, d = 0.1) {
    # dummy for DF that will contain the coordinates for points
    df <- data.frame(x1 = NA, x2 = NA)
    
    # counter for the num of times new suggested points were declined
    skipped <- 0
    # run while the number of rejections is lower than given threshold
    while (skipped < threshold) {
        # in order to present points on a circle, first, we sample two points
        # distributed uniformly then we choose only ones that are in the circle
        x1 <- runif(n = 1, min = -r, max = r)
        x2 <- runif(n = 1, min = -r, max = r)
        
        # boolen whether point w/ coordinates x1 and x2 lies on a disk
        in_circle <- sqrt(x1^2 + x2^2) <= r
        
        # if the point does lie on a dist
        if (in_circle) {
            # calculate the distances between each point and the suggested one
            neib_dist <- sqrt(abs(x1 - df$x1)^2 + abs(x2 - df$x2)^2)
            # calculate the num of points that is closer than d to the new point
            neib_numb <- sum(neib_dist < d, na.rm = TRUE)
            # boolean whether the suggested point has no points that is closer
            # than d to the new point or the suggested point is the first in DF
            no_neibor <- (neib_numb == 0) | is.na(neib_numb)
            
            # if the point does not have any neighbours
            if (no_neibor) {
                # add the suggested point to DF
                df <- rbind(df, c(x1, x2))
                # reset the counter
                skipped <- 0
            # if it already has a neighbouring point
            } else {
                # add to counter
                skipped <- skipped + 1
            }
        }
    }
    # reset the indexing (it is 2..n) --> 1..n
    df <- df[-1, ]
    rownames(df) <- NULL
    
    return(df)
}
```

The following code returns a DF that contains 'sample_size' points (with two coords) on a circle with radius `r` that no two points is closer to each other than `d` given initial set of points that is on the disk (`initial`)
```{r}
gibbs_sampler <- function(sample_size, r, initial) {
    # reassign initial set to some var
    df <- initial
    # number of elements in the set
    n <- nrow(initial)
    
    # dummy DF that we expect to be filled with sampled points
    sampled <- data.frame(x1 = NA, x2 = NA)
    # iterate until we sample the needed amount of points 
    # (+ 1 because it already has one row with NA's which will be deleted)
    while (nrow(sampled) < sample_size + 1) {
        
        # a random unif value
        U <- runif(n = 1)
        # calculate 'I' which is the index that we exclude from 
        idx <- as.integer((n - 1) * U) + 1
        
        # generate two coordinates for a suggested point on a disk w/ radius r
        x1 <- runif(n = 1, min = -r, max = r)
        x2 <- runif(n = 1, min = -r, max = r)
        
        # boolean weither the suggested point is on the disk
        in_circle <- sqrt(x1^2 + x2^2) <= r
        
        # if it is on the disk
        if (in_circle) {
            # the neibourhood of the point with 'idx' index in 'df'
            # the 'df' is rbinded with 'sampled' because the 'sampled' points 
            # should not be within the neibourhood with other 'sampled' points
            nighbours <- rbind(df[-idx, ], sampled)
            
            # calculate all distances between the suggested point and all points
            # except the one that is in idx, i. e. I
            neib_dist <- sqrt(abs(x1 - nighbours$x1)^2 + abs(x2 - nighbours$x2)^2)
            # calculate the num of points that is closer than d to the new point
            neib_numb <- sum(neib_dist < d, na.rm = TRUE)
            # boolean whether the suggested point has no points that is closer
            # than d to the new point or the suggested point is the first in DF
            no_neibor <- (neib_numb == 0) | is.na(neib_numb)
            
            # if the point does not have any neighbours
            if (no_neibor) {
                # add the suggested point to sample df
                sampled <- rbind(sampled, c(x1, x2))
            }
        }
    }
    # Delets 1st row. The 'sampled' was initiated with one row that has two NAs
    sampled <- sampled[-1, ]
    # reset the indexing (it is 2..n) --> 1..n
    rownames(sampled) <- NULL
    return(sampled)
}
```

Before we start sampling we shall choose some parameters
```{r}
# the amount of declined points on initialization. The higher threshold 
# the lower \beta = P[no two points are within d of each other]
threshold <- 10000
# the lowest distance between neighbours
d <- 1 / 10
# number of suggested points in the gibbs sampler
sam_size <- 20
```

Let's make some sample using the parameters specified above from a rv that distributed uniformly on a disk
```{r}
# initializing
init <- unif_circle(threshold = threshold, d = d)
# sampling using this initialization
smpl <- gibbs_sampler(sample_size = sam_size, r = 1, initial = init)
```

Now, let's plot the results
```{r, fig.align='center', fig.height=6, fig.width=6}
# plots the initial points (red)
plot(init, pch = 20, cex = 0.7, asp = 1, col = rgb(1, 0, 0, alpha = 0.3),
     xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2))
# add the generated ones to the plot (blue)
points(smpl, pch = 20, cex = 0.7, asp = 1, col = rgb(0, 0, 1, alpha = 0.3))
# also draw the neighourhoods for each point for initial set and gerenated
symbols(x = init$x1, y = init$x2, circles = rep(d / 2, nrow(init)), 
        inches = F, add = T, fg = rgb(1, 0, 0, alpha = 0.3))
symbols(x = smpl$x1, y = smpl$x2, circles = rep(d / 2, nrow(smpl)), 
        inches = F, add = T, fg = rgb(0, 0, 1, alpha = 0.3))
# add legend
legend(x = 'topright', c('Initial', 'New'), 
       col = c(rgb(1, 0, 0, alpha = 0.3), rgb(0, 0, 1, alpha = 0.3)),
       pch = c(20, 20), pt.bg = c('red', 'blue'))
```

But now let's solve the Exercise 10 b.
```{r}
threshold <- 10000
# number of suggested points in the gibbs sampler
need <- 9
# the lowest distance between neighbours
d <- 1 / 8
```

```{r}
init <- unif_circle(threshold = threshold, r = 1, d = d)
smpl <- gibbs_sampler(sample_size = need, r = 1, initial = init)
```

```{r, fig.align='center', fig.height=6, fig.width=6}
# first plotting the initial (red) points
plot(init, pch = 20, cex = 0.7, asp = 1, col = rgb(1, 0, 0, alpha = 0.3),
     xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2))
# add the generated ones (blue) on the disk. In case they haven't been changed
# two colors mix up to (red + blue = purple)
points(smpl, pch = 20, cex = 0.7, asp = 1, col = rgb(0, 0, 1, alpha = 0.3))
# also draw the neighourhoods for each point for initial set and gerenated
symbols(x = init$x1, y = init$x2, circles = rep(d / 2, nrow(init)), 
        inches = F, add = T, fg = rgb(1, 0, 0, alpha = 0.3))
symbols(x = smpl$x1, y = smpl$x2, circles = rep(d / 2, nrow(smpl)), 
        inches = F, add = T, fg = rgb(0, 0, 1, alpha = 0.3))
# add legend
legend(x = 'topright', c('Initial', 'New'), 
       col = c(rgb(1, 0, 0, alpha = 0.3), rgb(0, 0, 1, alpha = 0.3)),
       pch = c(20, 20), 
       pt.bg = c('red', 'blue'))
```

```{r}
print(smpl)
```

### 8 queens on a chessboard

```{r}
# return a random chessbord given number of queens for arbitrary chessboard
# matrix with 1 -- queen, 0 -- empty
init_cond <- function(queens, dims = c(8, 8)) {
    
    # if the number of queens is higher than the number of cells, raise an error
    if (prod(dims) < queens) {
        stop(paste('I cannot locate', queens, 'queens on', prod(dims), 'cells'))
    }
    
    # assign the dimentions of a needed chessboard
    dim_x <- dims[1]
    dim_y <- dims[2]
    # reserve a place for each queen
    chessboard <- matrix(data = 0, nrow = dim_x, ncol = dim_y)
    
    # until the number of queens left is not zero implement
    while (queens > 0) {
        # choose randomly the row and column positions
        idx_x <- floor(dim_x * runif(1) + 1)
        idx_y <- floor(dim_y * runif(1) + 1)
        
        # if the choosen cell is empty place a queen on it & reduce the counter
        if (chessboard[idx_x, idx_y] == 0) {
            chessboard[idx_x, idx_y] <- 1
            queens <- queens - 1
        }
    }
    return(chessboard)
}
```

```{r}
# returns an error
init_cond(queens = 120, dims = c(8, 8)) # error
```

```{r}
init_cond(queens = 8, dims = c(8, 8))
```

```{r}
# also works with NxM dimention of a chessboard
init_cond(queens = 80, dims = c(9, 11))
```


```{r}
# returns a list of neighbours for a given a queen (its index) and a condition
neighbourhood <- function(queen_idx, condition) {
    
    dim_x <- nrow(condition)
    dim_y <- ncol(condition)
    # for the sake of comprehension assign indeces to two different values
    i <- queen_idx[1]
    j <- queen_idx[2]
    # list of indices for each queen
    queens <- which(condition == 1, arr.ind = TRUE)
    # reserve a list
    neighbours <- list()
    
    ## in this problem there are four types of neighbouring:
    # vertical (|) neighbours for Q(i, j) are Q(k, j) 
    # for all k in [1, dim_x]
    domain <- seq(1, dim_x)
    
    # for each element in the domain
    for (d in 1:length(domain)) {
        k <- domain[d]
        
        # if the number of TRUEs is more than zero implement
        if (sum(queens[,1] == k & queens[,2] == j) > 0) {
            
            # to prevent: 'a queen is neighbour to herself'
            if (k != i) {
                # append the new index to the list
                neighbours <- c(neighbours, list(c(k, j)))
            }
        }
    }
    # horizontal (--) neighbours for Q(i, j) are Q(i, k) 
    # for all k in [1, dim_y]
    domain <- seq(1, dim_y)
    
    # for each element in the domain
    for (d in 1:length(domain)) {
        k <- domain[d]
        
        # if the number of TRUEs is more than zero implement
        if (sum(queens[,1] == i & queens[,2] == k) > 0) {
            
            # to prevent: 'a queen is neighbour to herself'
            if (k != j) {
                # append the new index to the list
                neighbours <- c(neighbours, list(c(i, k)))
            }
        }
    }
    # diag (\) neighbours for Q(i, j) are Q(i+k, j+k) 
    # for all k in [1-i, dim_x-i] intersect [1-j, dim_y-j]
    domain <- intersect(seq(1-i, dim_x-i), seq(1-j, dim_y-j))
    
    # for each element in the domain
    for (d in 1:length(domain)) {
        k <- domain[d]
        
        # if the number of TRUEs is more than zero implement
        if (sum(queens[,1] == (i + k) & queens[,2] == (j + k)) > 0) {
            
            # to prevent: 'a queen is neighbour to herself'
            if (k != 0) {
                # append the new index to the list
                neighbours <- c(neighbours, list(c((i + k), (j + k))))
            }
        }
    }
    # diag (/) neighbours for Q(i, j) are Q(i+k, j-k) 
    # for all k in [1-i, dim_x-i] intersect [-dim_y+j, -1+j]
    domain <- intersect(seq(1-i, dim_x-i), seq(-dim_y+j, -1+j))
    
    # for each element in the domain
    for (d in 1:length(domain)) {
        k <- domain[d]
        
        # if the number of TRUEs is more than zero implement
        if (sum(queens[,1] == (i + k) & queens[,2] == (j - k)) > 0) {
            
            # to prevent: 'a queen is neighbour to herself'
            if (k != 0) {
                # append the new index to the list
                neighbours <- c(neighbours, list(c((i + k), (j - k))))
            }
        }
    }
    return(neighbours)
}
```

```{r}
set.seed(1)
# let's randomly place 5 queens on 4 by 3 chessboard
condition <- init_cond(queens = 5, c(4, 3))
print(condition)
# for the queen that is placed on (1, 3) - see above - we have three neighbours
neighbourhood(queen_idx = c(1, 3), condition)
```


```{r}
# returns the number of queens that can be defeated by another given condition
energy <- function(condition) {
    
    dim_x <- nrow(condition)
    dim_y <- ncol(condition)
    # stays here! because it changes 
    queens <- which(condition == 1, arr.ind = TRUE)
    # reserve a list
    reachable <- list()
    
    # for each queen add its neighbours (the queens that can defeat this one)
    for (i in 1:nrow(queens)) {
        # assign the index to another variable
        queen_idx <- queens[i, ]
        # remove the names that were assigned by 'which' function above
        names(queen_idx) <- NULL
        # find the neighbours for a queen
        neighbours <- neighbourhood(queen_idx, condition)
        # add the neighbours to the list
        reachable <- c(reachable, neighbours)
    }
    # remove duplicates: Q(1, 1) defeats Q(2, 2) and vice-versa
    reachable <- unique(reachable)
    
    return(length(reachable))
}
```

```{r}
set.seed(2)
# for the sake of example, let's create some state
condition <- init_cond(queens = 4, dims = c(5, 6))
print(condition)
# then we calculate the energy for this condition
print(energy(condition))
```


It is 3 because we have three queens that can beat each other exept for (3, 2)

```{r}
# returns a changed condition that is different from the prev. one by one queen
change_cond <- function(condition) {
    
    dim_x <- nrow(condition)
    dim_y <- ncol(condition)
    
    # save the old condition
    old_cond <- condition
    
    # set the number of changes that are needed to make
    counter <- 1
    
    # until the needed change is made run
    while (counter != 0) {
        # choose randomly the indices of a queen that we want to move
        idx_x_from <- floor(dim_x * runif(1) + 1)
        idx_y_from <- floor(dim_y * runif(1) + 1)
        # choose randomly the indices where we want to move it
        idx_x_to <- floor(dim_x * runif(1) + 1)
        idx_y_to <- floor(dim_y * runif(1) + 1)
        
        # if a random cell does contain a queen AND another is empty move it
        if (condition[idx_x_from, idx_y_from] == 1 &
            condition[idx_x_to, idx_y_to] == 0) {
            condition[idx_x_from, idx_y_from] <- 0
            condition[idx_x_to, idx_y_to] <- 1
            # reduce the counter
            counter <- counter - 1
        }
    }
    # assing a list with the new and the old conditions
    lst <- list('old' = old_cond, 'new' = condition)
    return(lst)
}
```

```{r}
set.seed(3)
# # for the sake of example, let's create some another stae
condition <- init_cond(queens = 3, dims = c(3, 3))
print(condition)
```

```{r}
# then we may change one of the elements and compare two states
states <- change_cond(condition)
print(states)
```


```{r}
# returns whether to accept the new condition given both conditions and temperature
acceptance <- function(cond_old, cond_new, temperature) {
  
    # calculates the energy for both states
    energy_old <- energy(condition = cond_old)
    energy_new <- energy(condition = cond_new)
    
    # if the new energy is lower (we are minimizing) then accept
    if (energy_new < energy_old) {
      return(TRUE)
    } 
    
    # else accept new state with some probability 'prob'
    else {
      prob <- exp(-abs(energy_new - energy_old) / temperature)
      
      # if a randomly chosen value is lower than the probability accept
      if (runif(1) < prob) {
        return(TRUE)
      }
      else {
          return(FALSE)
      }
    }
}
```

```{r}
# returns the state with the optimum that the algorithm found given # of queens,
# dimentions, and whether to show the progress
simulated_annealing <- function(queens, dims, verbose = FALSE, temp_max = 1,
                                temp_min = 0.001, rate = 0.999) {
    
    # initial temperature is the max
    temperature <- temp_max
    
    # let's start with some initial state
    condition <- init_cond(queens, dims)
    
    # until temperature is high enough implement
    while (temperature > temp_min) {
        
        # create a list with old and new conditions
        old_new_cond <- change_cond(condition)
        
        # if the new condition is accepted, assign it to the current condition
        # (see also how 'acceptance' func works)
        if (acceptance(old_new_cond$old, old_new_cond$new, temperature)) {
            condition <- old_new_cond$new
        }
        
        # reduce the temperature
        temperature <- temperature * rate
        
        # if a user chooses to see the progress print some intermediate steps
        if (verbose) {
            print(paste0('Energy: ', energy(condition), 
                         '; Temperature: ', round(temperature, 4)))
        }
    }
    return(condition)
}
```

```{r}
set.seed(4)
# let's solve our task
sampled <- simulated_annealing(queens = 8, dims = c(8, 8))
print(sampled)
print(paste('Energy =', energy(condition = sampled)))
```
```{r}
# let's repeat with another seed
set.seed(5)
# let's solve our task
sampled <- simulated_annealing(queens = 8, dims = c(8, 8))
print(sampled)
print(paste('Energy =', energy(condition = sampled)))
```

One may see how the algorithm works in progress specifying `verbose` agrument as follows `verbose = TRUE`. This wasn't done in the first place for the purpose of saving space in this document.

### 100 draws for 3 points on a segment
```{r}
# returns an initial state for Gibbs' alg. given the values mentioned above
initial_draw <- function(n, range, d) {
    
    # error-check whether we can locate 'n' points on the given segment
    # for ex: at most 3 points might be located on [0, 1] with d = 0.5 :
    # 0.0, 0.5, 1.0.
    if ((n - 1) * d >= diff(range)) {
        stop(paste0('I cannot locate ', n, 
                    ' points with no neighbours on a segment [', range[1], ', ', 
                    range[2], '] because n * d is higher or equal than range'))
    }
    # to start the 'while'-loop we assign some arbitrary constant to it
    how_many_neighbours <- 1
    
    # the sum() is used since the 'neighbours' is a vector of booleans
    # repeat untile there is no neighbour that is close than d to a point
    while (how_many_neighbours != 0) {
        # randomly draw 'n' draws from uniform distribution given 'range'
        smpl <- runif(n, min = range[1], max = range[2])
        # combn() calculates difference for all 'n'-choose-'m' elements of smpl
        # since our purpose is to calculate distance, we take abs()
        distances <- abs(combn(x = smpl, m = 2, FUN = diff))
        # how many neighbours that is close than d to a point
        how_many_neighbours <- sum(distances < d)
    }
    return(smpl)
}
```


```{r}
print(initial_draw(n = 2, d = 0.1, range = c(0, 1)))
print(initial_draw(n = 4, d = 0.1, range = c(0, 1)))
print(initial_draw(n = 20, range(-100, 100), d = 3))
```

```{r}
# impossible to locate 12 poins on [0, 1] with d = 0.1
print(initial_draw(n = 12, d = 0.1, range = c(0, 1))) # error
```
```{r}
# impossible to calculate distance for one point
print(initial_draw(n = 1, d = 0.1, range = c(0, 1))) # error
```

```{r}
# returns a df with 'n' cols, 'size' rows. The points draw from segment 
# that is specified by 'range'. Neighbourhood distance is at least 'd'.
sampler_gibbs <- function(size, n, range, d) {
    # returns an initial state for Gibbs' alg. given the values mentioned above
    initial_draw <- function(n, range, d) {
        
        # error-check whether we can locate 'n' points on the given segment
        # for ex: at most 3 points might be located on [0, 1] with d = 0.5 :
        # 0.0, 0.5, 1.0.
        if ((n - 1) * d >= diff(range)) {
            stop(paste0('I cannot locate ', n, 
                        ' points with no neighbours on a segment [', range[1], 
                        ', ', range[2], 
                        '] because n * d is higher or equal than range'))
        }
        # to start the 'while'-loop we assign some arbitrary constant to it
        how_many_neighbours <- 1
        
        # the sum() is used since the 'neighbours' is a vector of booleans
        # repeat untile there is no neighbour that is close than d to a point
        while (how_many_neighbours != 0) {
            # randomly draw 'n' draws from uniform distribution given 'range'
            smpl <- runif(n, min = range[1], max = range[2])
            # combn() calculates difference for all 'n'-choose-'m' elements of smpl
            # since our purpose is to calculate distance, we take abs()
            distances <- abs(combn(x = smpl, m = 2, FUN = diff))
            # how many neighbours that is close than d to a point
            how_many_neighbours <- sum(distances < d)
        }
        return(smpl)
    }
    
    # let's initilize our Gibbs' sampler
    initial_state <- initial_draw(n, range, d)
    # create a df with the first draw that is the initial state
    sampled <- data.frame(t(initial_state))
    
    # until we don't have the needed number of draws, impliment
    while (nrow(sampled) < size) {
        
        # just to start the loop assign initial state to a candidate variable
        # that will be appended to the df that will be returned
        candidate <- initial_state
        
        # start counter
        counter <- 0
        # 'counter' is the number of times that we run the main step of
        # Gibbs' algorithm. It depends on the number of points 'n' and arbitrary 
        # const (5). 
        # Shuffle until counter is lower than (n * const)
        while (counter < (n * 5)) {
            # a random unif value
            U <- runif(n = 1)
            # calculate 'I' which is the index that we exclude from 
            idx <- as.integer(n * U) + 1
            # a random value that replaces a idx-th point in the initial state
            X <- runif(n = 1, min = range[1], max = range[2])
            # concatenate initial state w/o idx-th element and 'X'
            changed_candid <- c(candidate[-idx], X)
            # combn() calculates difference for all 'n'-choose-'m' elements of smpl
            # since our purpose is to calculate distance, we take abs()
            distances <- abs(combn(x = changed_candid, m = 2, FUN = diff))
            # how many neighbours that is close than d to a point
            how_many_neighbours <- sum(distances < d)
            
            # if we don't have a neighbour that is close than d to a point
            if (how_many_neighbours == 0) {
                # then assign it as our candidate
                candidate <- changed_candid
                # increase the counter (see 'while'-loop)
                counter <- counter + 1
            }
        }
        
        # rbind the candidate that we draw after shuffling and replacing elements
        sampled <- rbind(sampled, candidate)
    }
    return(sampled)
}
```

```{r}
# let's solve our task
temp <- sampler_gibbs(size = 100, n = 3, range = c(0, 1), d = 0.1)
print(head(temp, 10))

# then we may plot the empirical distribution for a bit larger sample
temp <- sampler_gibbs(size = 5000, n = 3, range = c(0, 1), d = 0.1)
plot(density(temp$X1, from = 0, to = 1), ylim = c(0, 1.1), 
     main = 'Density of the distribution of 3 points on a segment', col = 'red')
lines(density(temp$X2, from = 0, to = 1), col = 'blue')
lines(density(temp$X3, from = 0, to = 1), col = 'green')
```

It also works for an arbitrary `n`, `size`, `range`, and `d`.

```{r}
temp <- sampler_gibbs(size = 10, n = 5, range = c(-2, 3), d = 0.5)
print(temp)
```

### 5 numbers: their sum and their product (Ross, Exercise 10i)

```{r}
# returns the ratio of the number when the product of all x_i is higher than 120
Gibbs_prob <- function(iter = 1000) {
    # let's choose an arbitrary set of numbers that sum up to 15
    numbers <- seq(5)
    # start counter
    counter <- 0
    
    # repeat the following 'iter'times
    for (i in seq(iter)) {
        
        # choose indices of elements that will be replaced
        idx1 <- as.integer(5 * runif(1)) + 1
        idx2 <- as.integer(5 * runif(1)) + 1
        
        # make sure that indices are not the same
        while (idx1 == idx2) {
            idx2 <- as.integer(5 * runif(1)) + 1
        }
        
        # according to the prove 260 page we may calculate the rate as follows
        rate <- abs(1/idx1 - 1/idx2)
        # plug calculated rate into distribution
        x <- rexp(n = 1, rate)
        # replace the 'idx1' elem
        numbers[idx1] <- x
        # in order to keep the sum equal to 15 subtract all element excep for one
        numbers[idx2] <- 15 - sum(numbers[-idx2])
        
        # if the product of all numbers is 120 increase the counter
        if (prod(numbers) > 120) {
            counter <- counter + 1
        }
    }
    return(counter / iter)
}
```

```{r}
print(Gibbs_prob(iter = 10))
print(Gibbs_prob(iter = 100))
print(Gibbs_prob(iter = 1000))
print(Gibbs_prob(iter = 10000))
print(Gibbs_prob(iter = 100000))
print(Gibbs_prob(iter = 1000000))
```

